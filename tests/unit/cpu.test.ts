/**\n * Unit tests for CPU6502 emulator integration\n * Tests both 6502 and 65C02 processor variants\n */\n\nimport { CPU6502Emulator, CPUState, CPUType } from '../../src/core/cpu';\n\ndescribe('CPU6502Emulator', () => {\n  let cpu: CPU6502Emulator;\n  let memoryMap: Map<number, number>;\n  \n  beforeEach(() => {\n    cpu = new CPU6502Emulator();\n    memoryMap = new Map();\n    \n    // Set up memory callbacks\n    cpu.setMemoryCallbacks(\n      (address: number) => memoryMap.get(address) || 0xFF,\n      (address: number, value: number) => memoryMap.set(address, value & 0xFF)\n    );\n    \n    // Set up reset vector\n    memoryMap.set(0xFFFC, 0x00);\n    memoryMap.set(0xFFFD, 0x80); // Reset to $8000\n  });\n  \n  describe('Basic CPU Control', () => {\n    test('should initialize with correct default state', () => {\n      const state = cpu.getRegisters();\n      \n      expect(state.A).toBe(0);\n      expect(state.X).toBe(0);\n      expect(state.Y).toBe(0);\n      expect(state.SP).toBe(0xFF);\n      expect(state.P & 0x04).toBe(0x04); // Interrupt disable flag set\n      expect(state.cycles).toBe(0);\n    });\n    \n    test('should reset CPU to initial state', () => {\n      // Modify CPU state\n      cpu.setRegisters({ A: 0x42, X: 0x33, Y: 0x55, SP: 0x80 });\n      \n      // Reset CPU\n      cpu.reset();\n      \n      const state = cpu.getRegisters();\n      expect(state.A).toBe(0);\n      expect(state.X).toBe(0);\n      expect(state.Y).toBe(0);\n      expect(state.SP).toBe(0xFF);\n      expect(state.PC).toBe(0x8000); // From reset vector\n    });\n    \n    test('should get and set CPU registers', () => {\n      const newState: Partial<CPUState> = {\n        A: 0x42,\n        X: 0x33,\n        Y: 0x55,\n        PC: 0x1234,\n        SP: 0x80,\n        P: 0x25\n      };\n      \n      cpu.setRegisters(newState);\n      const state = cpu.getRegisters();\n      \n      expect(state.A).toBe(0x42);\n      expect(state.X).toBe(0x33);\n      expect(state.Y).toBe(0x55);\n      expect(state.PC).toBe(0x1234);\n      expect(state.SP).toBe(0x80);\n      expect(state.P).toBe(0x25);\n    });\n  });\n  \n  describe('CPU Type Selection', () => {\n    test('should default to 6502 CPU type', () => {\n      expect(cpu.getCPUType()).toBe('6502');\n    });\n    \n    test('should allow setting CPU type to 65C02', () => {\n      cpu.setCPUType('65C02');\n      expect(cpu.getCPUType()).toBe('65C02');\n    });\n    \n    test('should allow switching between CPU types', () => {\n      cpu.setCPUType('65C02');\n      expect(cpu.getCPUType()).toBe('65C02');\n      \n      cpu.setCPUType('6502');\n      expect(cpu.getCPUType()).toBe('6502');\n    });\n  });\n  \n  describe('Breakpoint Management', () => {\n    test('should set and check breakpoints', () => {\n      expect(cpu.hasBreakpoint(0x8000)).toBe(false);\n      \n      cpu.setBreakpoint(0x8000);\n      expect(cpu.hasBreakpoint(0x8000)).toBe(true);\n    });\n    \n    test('should remove breakpoints', () => {\n      cpu.setBreakpoint(0x8000);\n      expect(cpu.hasBreakpoint(0x8000)).toBe(true);\n      \n      cpu.removeBreakpoint(0x8000);\n      expect(cpu.hasBreakpoint(0x8000)).toBe(false);\n    });\n    \n    test('should clear all breakpoints', () => {\n      cpu.setBreakpoint(0x8000);\n      cpu.setBreakpoint(0x8010);\n      cpu.setBreakpoint(0x8020);\n      \n      expect(cpu.hasBreakpoint(0x8000)).toBe(true);\n      expect(cpu.hasBreakpoint(0x8010)).toBe(true);\n      expect(cpu.hasBreakpoint(0x8020)).toBe(true);\n      \n      cpu.clearBreakpoints();\n      \n      expect(cpu.hasBreakpoint(0x8000)).toBe(false);\n      expect(cpu.hasBreakpoint(0x8010)).toBe(false);\n      expect(cpu.hasBreakpoint(0x8020)).toBe(false);\n    });\n    \n    test('should halt execution at breakpoint', () => {\n      cpu.setBreakpoint(0x8000);\n      \n      // Set PC to breakpoint address\n      cpu.setRegisters({ PC: 0x8000 });\n      \n      // Step should return 0 cycles (halted)\n      const cycles = cpu.step();\n      expect(cycles).toBe(0);\n    });\n  });\n  \n  describe('Interrupt Control', () => {\n    test('should trigger and clear IRQ', () => {\n      expect(cpu.isIRQPending()).toBe(false);\n      \n      cpu.triggerIRQ();\n      expect(cpu.isIRQPending()).toBe(true);\n      \n      cpu.clearIRQ();\n      expect(cpu.isIRQPending()).toBe(false);\n    });\n    \n    test('should trigger NMI', () => {\n      expect(cpu.isNMIPending()).toBe(false);\n      \n      cpu.triggerNMI();\n      expect(cpu.isNMIPending()).toBe(true);\n    });\n    \n    test('should handle NMI interrupt', () => {\n      // Set up NMI vector\n      memoryMap.set(0xFFFA, 0x00);\n      memoryMap.set(0xFFFB, 0x90); // NMI vector at $9000\n      \n      // Set initial PC\n      cpu.setRegisters({ PC: 0x8000 });\n      \n      // Trigger NMI\n      cpu.triggerNMI();\n      \n      // Step should handle the NMI\n      const cycles = cpu.step();\n      expect(cycles).toBe(7); // NMI takes 7 cycles\n      \n      // PC should now point to NMI vector\n      const state = cpu.getRegisters();\n      expect(state.PC).toBe(0x9000);\n      expect(state.P & 0x04).toBe(0x04); // Interrupt disable flag set\n    });\n  });\n  \n  describe('Instruction Execution', () => {\n    test('should execute NOP instruction', () => {\n      // Set up NOP instruction at PC\n      cpu.setRegisters({ PC: 0x8000 });\n      memoryMap.set(0x8000, 0xEA); // NOP\n      \n      const initialState = cpu.getRegisters();\n      const cycles = cpu.step();\n      const finalState = cpu.getRegisters();\n      \n      expect(cycles).toBe(2); // NOP takes 2 cycles\n      expect(finalState.PC).toBe(initialState.PC + 1);\n      expect(finalState.cycles).toBe(initialState.cycles + 2);\n    });\n    \n    test('should execute JMP absolute instruction', () => {\n      // Set up JMP $1234 instruction\n      cpu.setRegisters({ PC: 0x8000 });\n      memoryMap.set(0x8000, 0x4C); // JMP absolute\n      memoryMap.set(0x8001, 0x34); // Low byte of target\n      memoryMap.set(0x8002, 0x12); // High byte of target\n      \n      const cycles = cpu.step();\n      const state = cpu.getRegisters();\n      \n      expect(cycles).toBe(3); // JMP takes 3 cycles\n      expect(state.PC).toBe(0x1234);\n    });\n    \n    test('should execute LDA immediate instruction', () => {\n      // Set up LDA #$42 instruction\n      cpu.setRegisters({ PC: 0x8000, A: 0x00 });\n      memoryMap.set(0x8000, 0xA9); // LDA immediate\n      memoryMap.set(0x8001, 0x42); // Immediate value\n      \n      const cycles = cpu.step();\n      const state = cpu.getRegisters();\n      \n      expect(cycles).toBe(2); // LDA immediate takes 2 cycles\n      expect(state.A).toBe(0x42);\n      expect(state.PC).toBe(0x8002);\n      \n      // Check flags\n      expect(state.P & 0x02).toBe(0); // Zero flag clear\n      expect(state.P & 0x80).toBe(0); // Sign flag clear\n    });\n    \n    test('should set zero flag for LDA #$00', () => {\n      // Set up LDA #$00 instruction\n      cpu.setRegisters({ PC: 0x8000, A: 0xFF });\n      memoryMap.set(0x8000, 0xA9); // LDA immediate\n      memoryMap.set(0x8001, 0x00); // Zero value\n      \n      cpu.step();\n      const state = cpu.getRegisters();\n      \n      expect(state.A).toBe(0x00);\n      expect(state.P & 0x02).toBe(0x02); // Zero flag set\n      expect(state.P & 0x80).toBe(0); // Sign flag clear\n    });\n    \n    test('should set sign flag for LDA #$80', () => {\n      // Set up LDA #$80 instruction\n      cpu.setRegisters({ PC: 0x8000, A: 0x00 });\n      memoryMap.set(0x8000, 0xA9); // LDA immediate\n      memoryMap.set(0x8001, 0x80); // Negative value\n      \n      cpu.step();\n      const state = cpu.getRegisters();\n      \n      expect(state.A).toBe(0x80);\n      expect(state.P & 0x02).toBe(0); // Zero flag clear\n      expect(state.P & 0x80).toBe(0x80); // Sign flag set\n    });\n  });\n  \n  describe('Memory Access', () => {\n    test('should use memory callbacks for reads and writes', () => {\n      let readAddress = -1;\n      let writeAddress = -1;\n      let writeValue = -1;\n      \n      cpu.setMemoryCallbacks(\n        (address: number) => {\n          readAddress = address;\n          return memoryMap.get(address) || 0xFF;\n        },\n        (address: number, value: number) => {\n          writeAddress = address;\n          writeValue = value;\n          memoryMap.set(address, value);\n        }\n      );\n      \n      // Execute instruction that reads memory\n      cpu.setRegisters({ PC: 0x8000 });\n      memoryMap.set(0x8000, 0xEA); // NOP\n      \n      cpu.step();\n      \n      expect(readAddress).toBe(0x8000); // Should have read the opcode\n    });\n    \n    test('should handle memory access during reset', () => {\n      let resetVectorRead = false;\n      \n      cpu.setMemoryCallbacks(\n        (address: number) => {\n          if (address === 0xFFFC || address === 0xFFFD) {\n            resetVectorRead = true;\n          }\n          return memoryMap.get(address) || 0xFF;\n        },\n        (address: number, value: number) => {\n          memoryMap.set(address, value);\n        }\n      );\n      \n      cpu.reset();\n      \n      expect(resetVectorRead).toBe(true);\n    });\n  });\n  \n  describe('Error Handling', () => {\n    test('should handle unknown opcodes gracefully', () => {\n      // Set up unknown opcode\n      cpu.setRegisters({ PC: 0x8000 });\n      memoryMap.set(0x8000, 0xFF); // Unknown opcode\n      \n      const initialPC = cpu.getRegisters().PC;\n      const cycles = cpu.step();\n      const finalPC = cpu.getRegisters().PC;\n      \n      // Should advance PC and return some cycles\n      expect(finalPC).toBeGreaterThan(initialPC);\n      expect(cycles).toBeGreaterThan(0);\n    });\n    \n    test('should handle missing memory callbacks', () => {\n      const newCpu = new CPU6502Emulator();\n      \n      // Should not throw when stepping without memory callbacks\n      expect(() => {\n        newCpu.step();\n      }).not.toThrow();\n    });\n  });\n});"}